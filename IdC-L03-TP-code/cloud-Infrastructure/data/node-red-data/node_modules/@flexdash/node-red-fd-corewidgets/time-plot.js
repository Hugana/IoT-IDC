// Node-RED node implementation for FlexDash widget TimePlot

module.exports = function (RED) {

  const widgetProps = {
  "title": {
    "name": "title",
    "name_text": "Title",
    "name_kebab": "title",
    "msg_name": "title",
    "type": "string",
    "input_type": "str",
    "tip": "Text to display in the widget header. ",
    "default": "Time Plot",
    "default_html": "'Time Plot'"
  },
  "popup_info": {
    "name": "popup_info",
    "name_text": "Popup Info",
    "name_kebab": "popup-info",
    "msg_name": "popup_info",
    "type": "string",
    "input_type": "str",
    "tip": "Info text to display in (i) pop-up. ",
    "default": null,
    "default_html": null
  },
  "data": {
    "msg_name": "payload",
    "name": "data",
    "name_text": "Payload",
    "name_kebab": "data",
    "tip": "Array of row-wise data or a single row. ",
    "default": null,
    "default_html": null,
    "type": "array",
    "input_type": "json"
  },
  "labels": {
    "msg_name": "labels",
    "name": "labels",
    "name_text": "Labels",
    "name_kebab": "labels",
    "tip": "Array of labels for series. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "colors": {
    "msg_name": "colors",
    "name": "colors",
    "name_text": "Colors",
    "name_kebab": "colors",
    "tip": "Array of colors for series, names or #rrggbb. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "axes": {
    "msg_name": "axes",
    "name": "axes",
    "name_text": "Axes",
    "name_kebab": "axes",
    "tip": "Array to assign series to 'left' or 'right' axis. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "widths": {
    "msg_name": "widths",
    "name": "widths",
    "name_text": "Widths",
    "name_kebab": "widths",
    "tip": "Array of stroke widths for series, default is 2. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "points": {
    "msg_name": "points",
    "name": "points",
    "name_text": "Points",
    "name_kebab": "points",
    "tip": "Array of bool to show points on lines. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "span_gaps": {
    "msg_name": "span_gaps",
    "name": "span_gaps",
    "name_text": "Span Gaps",
    "name_kebab": "span-gaps",
    "tip": "Array of bool to span over nulls, default is false. ",
    "default": [],
    "default_html": "[]",
    "type": "array",
    "input_type": "json"
  },
  "left_unit": {
    "msg_name": "left_unit",
    "name": "left_unit",
    "name_text": "Left Unit",
    "name_kebab": "left-unit",
    "tip": "Unit to label left axis. ",
    "default": "",
    "default_html": "",
    "type": "string",
    "input_type": "str"
  },
  "left_min": {
    "msg_name": "left_min",
    "name": "left_min",
    "name_text": "Left Min",
    "name_kebab": "left-min",
    "tip": "Minimum for left axis. ",
    "default": null,
    "default_html": null,
    "type": "number",
    "input_type": "num"
  },
  "left_max": {
    "msg_name": "left_max",
    "name": "left_max",
    "name_text": "Left Max",
    "name_kebab": "left-max",
    "tip": "Maximum for left axis. ",
    "default": null,
    "default_html": null,
    "type": "number",
    "input_type": "num"
  },
  "left_decimals": {
    "msg_name": "left_decimals",
    "name": "left_decimals",
    "name_text": "Left Decimals",
    "name_kebab": "left-decimals",
    "tip": "Decimals on left axis. ",
    "default": 1,
    "default_html": "1",
    "type": "number",
    "input_type": "num"
  },
  "left_isoprefix": {
    "msg_name": "left_isoprefix",
    "name": "left_isoprefix",
    "name_text": "Left Isoprefix",
    "name_kebab": "left-isoprefix",
    "tip": "Use SI prefix on left axis. ",
    "default": false,
    "default_html": "false",
    "type": "boolean",
    "input_type": "bool"
  },
  "left_log": {
    "msg_name": "left_log",
    "name": "left_log",
    "name_text": "Left Log",
    "name_kebab": "left-log",
    "tip": "Use log scale on left axis. ",
    "default": false,
    "default_html": "false",
    "type": "boolean",
    "input_type": "bool"
  },
  "right_unit": {
    "msg_name": "right_unit",
    "name": "right_unit",
    "name_text": "Right Unit",
    "name_kebab": "right-unit",
    "tip": "Unit to label right axis. ",
    "default": "",
    "default_html": "",
    "type": "string",
    "input_type": "str"
  },
  "right_min": {
    "msg_name": "right_min",
    "name": "right_min",
    "name_text": "Right Min",
    "name_kebab": "right-min",
    "tip": "Minimum for right axis. ",
    "default": null,
    "default_html": null,
    "type": "number",
    "input_type": "num"
  },
  "right_max": {
    "msg_name": "right_max",
    "name": "right_max",
    "name_text": "Right Max",
    "name_kebab": "right-max",
    "tip": "Maximum for right axis. ",
    "default": null,
    "default_html": null,
    "type": "number",
    "input_type": "num"
  },
  "right_decimals": {
    "msg_name": "right_decimals",
    "name": "right_decimals",
    "name_text": "Right Decimals",
    "name_kebab": "right-decimals",
    "tip": "Decimals on right axis. ",
    "default": 1,
    "default_html": "1",
    "type": "number",
    "input_type": "num"
  },
  "right_isoprefix": {
    "msg_name": "right_isoprefix",
    "name": "right_isoprefix",
    "name_text": "Right Isoprefix",
    "name_kebab": "right-isoprefix",
    "tip": "Use SI prefix on right axis. ",
    "default": false,
    "default_html": "false",
    "type": "boolean",
    "input_type": "bool"
  },
  "right_log": {
    "msg_name": "right_log",
    "name": "right_log",
    "name_text": "Right Log",
    "name_kebab": "right-log",
    "tip": "Use log scale on right axis. ",
    "default": false,
    "default_html": "false",
    "type": "boolean",
    "input_type": "bool"
  },
  "reverse_legend": {
    "msg_name": "reverse_legend",
    "name": "reverse_legend",
    "name_text": "Reverse Legend",
    "name_kebab": "reverse-legend",
    "tip": "Reverse legend order. ",
    "default": false,
    "default_html": "false",
    "type": "boolean",
    "input_type": "bool"
  },
  "max_points": {
    "msg_name": "max_points",
    "name": "max_points",
    "name_text": "Max Points",
    "name_kebab": "max-points",
    "tip": "Max data points (int) or period ([0-9]*[smhd] for secs/mins/hrs/days). ",
    "default": null,
    "default_html": null,
    "input_type": "any"
  }
}
  const widgetDefaults = Object.fromEntries(Object.values(widgetProps).map(p => [p.name, p.default]))

  // Instantiate the Node-RED node, 'this' is the node being constructed
  // and config contains the values set by the user in the flow editor.
  function TimePlot(config) {
    RED.nodes.createNode(this, config)

    // Create missing node properties. This is to deal with the fact that if node properties are
    // added in an upgrade then nodes in existing flows don't have them. Besides not having the
    // expected defaults, this breaks the "widget-has-property" check when setting dynamic prop
    // values.
    for (const prop in widgetDefaults) {
      if (!config.hasOwnProperty(prop)) {
        config[prop] = widgetDefaults[prop]
        this.debug("Missing property: " + prop + " added with default: " + config[prop])
      }
    }
  
    // Initialize the widget by pushing the config to its props and get a handle
    // onto the FlexDash widget API.
    // The third arg is the kind of widget to create, if it doesn't exist
    const widget = RED.plugins.get('flexdash').initWidget(this, config, 'TimePlot')
    if (!widget) return // missing config node, thus no FlexDash to hook up to, nothing to do here

    let onNodeRedCustom, onFlexDashCustom
    // Custom handlers for Node-RED FlexDash Time-Plot node
// Copyright Â©2022 by Thorsten von Eicken, see LICENSE

// handler for Node-RED messages coming into the node, receives props (shallow clone of msg)
// can modify them, and returns bool: handling is aborted if false
onNodeRedCustom = (props, options) => {
    // special handling for payload
    if (props.data) {
        this.warn("msg.data is deprecated, please use msg.payload instead")
        props.payload = props.data
        delete props.data
    }
    if ('payload' in props) {
        const pl = props.payload
        delete props.payload
        if (pl !== null && !Array.isArray(pl)) {
            this.warn("Invalid payload, must be array or null")
            return
        }

        // full array update
        if (pl === null || pl.length == 0 || Array.isArray(pl[0])) {
            // array of arrays: the whole data set is being replaced, we can pass this through as-is
            // perform validation to save users from endless troubleshooting
            if (pl !== null && pl.length > 0) {
                const n0 = pl[0].length
                if (n0 < 1) {
                    this.warn(`msg.payload[0] has ${n0} values, expected at least 1 (time)`)
                    return
                } else if (n0 > 100) {
                    this.warn(`msg.payload[0] has ${n0} values, expected at most 100`)
                    return
                }
                for (let i=1; i<pl.length; i++) {
                    if (!Array.isArray(pl[i])) {
                        this.warn(`msg.payload[${i}] is not an array, got ${pl[i]}`)
                        return
                    }
                    if (pl[i].length != n0) {
                        this.warn(`msg.payload[${i}] has ${pl[i].length} values, expected ${n0}`)
                        return
                    }
                    for (let j=0; j<n0; j++) {
                        if (typeof pl[i][j] != 'number' && pl[i][j] != null) {
                            this.warn(`msg.payload[${i}][${j}] is not a number or null, got ${pl[i][j]}`)
                            return
                        }
                    }
                }
            }
            props.data = pl
            return
        }

        for (let i=0; i<pl.length; i++) {
            if (typeof pl[i] != 'number' && typeof pl[i] != null) {
                this.warn(`msg.payload[${i}] is not a number or null, got ${pl[i][j]}`)
                return
            }
        }

        // single data point append
        //this.log(`Single data point: ${pl}`)
        if (props._fd_socket) {
            this.error("Cannot unicast (_fd_socket!=null) single data points")
            return
        }

        // check cardinality
        let data = widget.get("data", options)
        //console.log(`Cardinality: ${JSON.stringify(data)}`)
        if (Array.isArray(data) && data.length > 0 && data[0].length != pl.length) {
            this.error(`Data point has ${pl.length} values, expected ${data[0].length}`)
            return
        }

        // append data point to existing data set
        widget.push("data", pl, options)

        // remove old data points if necessary
        data = widget.get("data", options)
        const max_points = widget.get("max_points", options)
        if (Number.isFinite(max_points)) {
            // limit the number of data points
            for (let i=0; i<data.length-max_points; i++) widget.shift("data", options)
        } else if(typeof max_points === 'string') {
            // limit the age of the oldest data point
            const max = Number.parseInt(max_points)
            const unit = max_points.slice(-1)
            if (Number.isFinite(max)) {
                let limit = Math.trunc(Date.now()/1000)
                switch (unit) {
                    case 's': limit -= max; break
                    case 'm': limit -= max * 60; break
                    case 'h': limit -= max * 3600; break
                    case 'd': limit -= max * 86400; break
                    default: this.warn("Invalid unit for max_points: " + unit); limit = 0; break
                }
                while (data.length > 0 && data[0][0] < limit) widget.shift("data", options)
            }
        }

        // hard limit the number of data points to 10k
        for (let i=0; i<data.length-10000; i++) widget.shift("data", options)
    }
}


    // handle flow input messages, basically massage them a bit and update the FD widget
    this.on("input", msg => {
      // if message has a topic and a `_delete` property then delete array-widget topic
      if ('topic' in msg && msg._delete) {
        widget.deleteTopic(msg.topic)
        return
      }
      // prepare update of widget props
      const props = Object.assign({}, msg) // shallow clone
      const options = { topic: msg.topic, socket: msg._fd_socket}
      delete props.topic
      // custom handler or built-in
      if (onNodeRedCustom) {
        onNodeRedCustom(props, options)
      } else {
        // remap msg.payload to the prop expected by the widget
        if ('data' && 'payload' in props) {
          props['data'] = props.payload
          delete props.payload
        }
      }
      if (props != {}) widget.setProps(props, options)
    })

    // handle messages from the widget, we receive the potential array element topic, the payload
    // sent by the widget, and the socket ID
    if (false) {
      widget.onInput((topic, payload, socket) => {
        let msg
        if (onFlexDashCustom) {
          msg = onFlexDashCustom(topic, payload, socket)
        } else {
          // propagate the payload into the flow and attach the FD socket ID
          msg = { payload: payload, _fd_socket: socket }
          // if loopback is requested, feed the message back to ourselves, implementation-wise,
          // set the payload property of the widget to the payload of the message
          if (config.fd_loopback) {
            // remap msg.payload to the prop expected by the widget
            const pl = 'data' || 'payload'
            console.log(`loopback: ${pl} <= ${payload}`)
            // WARNING: loopback is broadcast, this could have "interesting" effects
            widget.set(pl, payload, {topic}) // do we need to make a shallow clone here?
          }
        }
        if (topic != undefined) msg.topic = topic // array elt topic has priority
        else if (config.fd_output_topic) msg.topic = config.fd_output_topic // optional non-array topic
        this.send(msg)
      })
    }
  }

  RED.nodes.registerType("fd-time-plot", TimePlot)
}
